% !TEX root = report.tex

\section{Introduction}\label{sec:introduction}

\textit{Gossip protocols} are protocols that describe the way rumors---or, more generally, secrets---are shared in multi-agent environments.
The goal of the protocols is to communicate all secrets to all agents.
A lot of research has been done in this field, 
starting with research on the spread of infectious diseases \parencite{kermack_contribution_1927}.

The definition of the gossip problem generally used nowadays was first introduced in \citeyear{hajnal_cure_1972} by \citeauthor{hajnal_cure_1972}.\footnote{TODO: Tijdeman (1971) might have been earlier, but I have not been able to find a pdf of that paper. It is referenced in \Textcite{van_ditmarsch_dynamic_2018} though.}
In short, agents are represented as nodes in a graph, with the edges representing a relation.
This relation can be either the number relation \(N\), representing that one agent has the ``phone number'' of another agent,
and the secret relation \(S\), representing that one agent knows the secret of another agent.
\Citeauthor{hajnal_cure_1972} proved that this can be done in \(2n-4\) calls, where \(n\) is the number of agents, if all agents know the numbers of all other agents---that is, the number relation \(N\) is \textit{complete}.

The problem as formulated above requires the oversight of a central authority in order to know whether all agents know all secrets.
However, there are many applications where this is not feasible or desirable\footnote{TODO: maybe find a citation for this? Or just explain it better}.
Another problem is that it often cannot be guaranteed that all agents can contact all other agents.
This has led to the sub-fields of \textit{distributed gossip}, addressing the first issue, and \textit{dynamic gossip}, addressing the second.
The combination of these fields, where there is no overseer and not all agents can contact all other agents, is called \textit{distributed dynamic gossip}.

% TODO: explain protocols here

This paper will describe a tool that has been developed to aid research in distributed dynamic gossip.
% ? why? van ditmarsch (2018) states "We do not know approaches that combine dynamic gossip and distributed gossip for 
% ? protocols other than making random calls (i.e., protocol ANY)." so new protocol development might be a reason
It is able to visualise the connections between agents, allows exploring the execution tree of different (semi-arbitrary) protocols and validate call sequences given a graph and/or a protocol

\subsection{Notation}\label{sec:notation}

This paper takes its notation from \Textcite{van_ditmarsch_dynamic_2018} and \Textcite{van_ditmarsch_strengthening_2019}.
The used notation is explained below.

\begin{definition}[Gossip graph]
    % TODO: this should mention somewhere that gossip graphs are directed; otherwise the converse relation doesn't make sense
    % also maybe explain that a relation is a set of tuples? Or maybe \(N, S \subseteq A^2\) already says that
    Let \(A\) be a set of agents \(\{a, b, \dots\}\).
    Two binary relations on \(A\) are defined: \(N, S \subseteq A^2\).
    The first denotes the \textit{number} relation, the second the \textit{secret} relation.
    A gossip graph \(G\) is then defined as the a triple \((A, N, S)\).
\end{definition}

% TODO: maybe add definition of a relation (i.e. set of directed edges?)
%       the numbering would make more sense in that case

\begin{subdefinition}[Binary relation]
    \(Pxy\) says that agent \(x\) has relation \(P\) to agent \(y\).
    
    Formally: \((x, y) \in P\)
    \label{def:rel-bin}
\end{subdefinition}

\begin{subdefinition}[Identity relation]
    \(I_A\) is the set of relations where all agents have a relation to themselves.
    
    Formally: \(\{(x,x) \mid x \in A\}\)
    \label{def:rel-id}
\end{subdefinition}

\begin{subdefinition}[Converse relation]
    \(P^{-1}\) is the set of relations in \(P\), but with their direction switched.

    Formally: \(P^{-1} = \{(x,y) \mid Pyx\}\)
    \label{def:rel-conv}
\end{subdefinition}

\begin{subdefinition}[Composition relation]
    The composition of the relations \(P\) and \(Q\) is a new relation such that the tuple \((x,z)\) is in said new relation iff there exists another agent y such that \((x,y) \in P\) and \((y,z) \in Q\).

    Formally: \(P \circ Q = \{(x,z) \mid \exists y ((x, y) \in P \land (y, z) \in Q) \}\)
    \label{def:rel-comp}
\end{subdefinition}

\begin{subdefinition}
    \(P_x\) represents the agents \(x\) has relation \(P\) with.

    Formally: \(P_x = \{ y \in A \mid Pxy \}\)
    \label{def:rel-acq} % acq for acquaintances ('acquaintance relation' might be a nice name for this relation)
\end{subdefinition}

\begin{subdefinition}
    \(P^i\) represents the \(i\)th composition of relation \(P\) with itself.

    Formally: 
    \[
        P^i = 
        \begin{cases}
            P               & \text{for} \; i = 1\\
            P^{i-1} \circ P & \text{for} \; i > 1
        \end{cases}
    \]
    \label{def:rel-icomp}
\end{subdefinition}

\begin{subdefinition}
    % ? is this description right? It might also be infinite composition
    \(P^*\) represents the set of binary relations that are obtained through repeated relation composition of \(P\) with itself.

    Formally:
    \[
        \bigcup_{i \geq 1} P^i
    \]
    \label{def:rel-star} % not sure what to call this relation
\end{subdefinition}

% TODO: finish writing the notation. I have a notes file containing all notation, just have to convert it to latex

\subsection{Implementation}

This project uses Elm, a statically typed functional programming language for web development with its roots in Functional Reactive Programming \parencite{czaplicki_asynchronous_2013}.
This has several advantages:

\begin{enumerate}
    \item Implementing mathematical functions is more natural in functional languages because functions in Elm are pure;
    \item Elm is compiled to vanilla Javascript, ensuring the application will work in virtually all browsers;
    \item Elm does static type checking while compiling, ensuring type safety and thus reducing runtime errors;
\end{enumerate}

Another advantage of using a functional language is that much of the notation introduced in section~\ref{sec:notation} can be translated fairly directly.
For example, to evaluate protocol conditions, the last call in a call sequence needs to be checked.
Where in mathematical notation this is represented as \(\sigma_x = \tau \conc xy\) (``the last call in the sequence of calls containing \(x\) was a call made by \(x\) to another agent \(y\)''), this can be represented in Elm as follows:

% TODO: make this a listing so I can refer to it
\begin{lstlisting}[caption={\(\sigma_x = \tau \conc xy\) in Elm}, label=lst:elm-ex-1]
lastFrom x sigma_x = 
    case reverse sigma_x of
        [] ->
            False
        
        (from, to) :: tau ->
            from == x
\end{lstlisting}

This states that if \(\sigma_x = \epsilon\), the condition is false. 
Otherwise, it checks to see if the last call was made by x, and returns true if that is the case.

% - gossip protocols
% - reference some papers indicating origin of problem
% - explain dynamic gossip
% - examples of applications
% - rationale for building a tool
%   - visualise protocol execution
%   - exploration of new protocols

